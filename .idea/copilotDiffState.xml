<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/client/lib/listeners/on_move_user.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/listeners/on_move_user.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../controllers/grid_interaction_controller.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;&#10;void onMoveUser(BuildContext context, GridInteractionController gridController, ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; users, void Function(GrpcUser) onSelectedUserChanged, GrpcUser user) async {&#10;  final Logger logger = Logger();&#10;  &#10;  try {&#10;    final size = MediaQuery.of(context).size;&#10;    final UserResponse response = await GrpcClient().moveUser(user.username);&#10;    if (response.status == TrackerStatus.OK) {&#10;&#10;      // Extract coordinates from message format containing {&quot;x&quot;:123, &quot;y&quot;:456}&#10;      final RegExp coordsPattern = RegExp(r':\s*(-?\d+)');&#10;      final match = coordsPattern.allMatches(response.message);&#10;      &#10;      // Extract all matched numbers and convert to integers&#10;      List&lt;double&gt; numbers = match&#10;          .map((m) =&gt; m.group(1)!)&#10;          .map((s) =&gt; double.parse(s))&#10;          .toList();&#10;&#10;      final newX = numbers[0];&#10;      final newY = numbers[1];&#10;&#10;      // Create a temporary user with the new position&#10;      final movedUser = GrpcUser(&#10;        username: user.username,&#10;        currentX: newX,&#10;        currentY: newY,&#10;      );&#10;      movedUser.color = user.color;&#10;      movedUser.showPath = false;&#10;&#10;      // Update the existing users map&#10;      final updatedUsers = Map&lt;String, GrpcUser&gt;.from(users.value);&#10;      updatedUsers[user.username] = movedUser;&#10;      users.value = updatedUsers;  // This will trigger the ValueListenable&#10;&#10;      logger.info('Moved user ${user.username} to ($newX, $newY)');&#10;&#10;      // Update the selected user and zoom&#10;      zoomToUser(gridController, size, movedUser);&#10;      onSelectedUserChanged(movedUser);&#10;    } else {&#10;      logger.error('Failed to move user -&gt; $response');&#10;    }&#10;  } catch (e) {&#10;    logger.error('Error moving user: $e');&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../controllers/grid_interaction_controller.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;&#10;void onMoveUser(BuildContext context, GridInteractionController gridController, ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; users, void Function(GrpcUser) onSelectedUserChanged, GrpcUser user) async {&#10;  final Logger logger = Logger();&#10;  &#10;  try {&#10;    final size = MediaQuery.of(context).size;&#10;    final UserResponse response = await GrpcClient().moveUser(user.username);&#10;    if (response.status == TrackerStatus.OK) {&#10;&#10;      // Extract coordinates from message format containing {&quot;x&quot;:123, &quot;y&quot;:456}&#10;      final RegExp coordsPattern = RegExp(r':\s*(-?\d+)');&#10;      final match = coordsPattern.allMatches(response.message);&#10;      &#10;      // Extract all matched numbers and convert to integers&#10;      List&lt;double&gt; numbers = match&#10;          .map((m) =&gt; m.group(1)!)&#10;          .map((s) =&gt; double.parse(s))&#10;          .toList();&#10;&#10;      final newX = numbers[0];&#10;      final newY = numbers[1];&#10;&#10;      // Create a temporary user with the new position&#10;      final movedUser = GrpcUser(&#10;        username: user.username,&#10;        currentX: newX,&#10;        currentY: newY,&#10;      );&#10;      movedUser.color = user.color;&#10;      movedUser.showPath = false;&#10;&#10;      // Update the existing users map&#10;      final updatedUsers = Map&lt;String, GrpcUser&gt;.from(users.value);&#10;      updatedUsers[user.username] = movedUser;&#10;      users.value = updatedUsers;  // This will trigger the ValueListenable&#10;&#10;      logger.info('Moved user ${user.username} to ($newX, $newY)');&#10;&#10;      // Update the selected user and zoom&#10;      zoomToUser(gridController, size, movedUser);&#10;      onSelectedUserChanged(movedUser);&#10;    } else {&#10;      logger.error('Failed to move user -&gt; $response');&#10;    }&#10;  } catch (e) {&#10;    logger.error('Error moving user: $e');&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/client/lib/pages/grpc_home.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/pages/grpc_home.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/controllers/grid_interaction_controller.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../widgets/new_user_input.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../painters/coordinate_grid_painter.dart';&#10;import '../widgets/existing_users.dart';&#10;import '../singletons/app_config.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;import '../listeners/on_move_user.dart';&#10;&#10;class GrpcHomePage extends StatefulWidget {&#10;  const GrpcHomePage({super.key, required this.title});&#10;&#10;  final String title;&#10;&#10;  @override&#10;  State&lt;GrpcHomePage&gt; createState() =&gt; _GrpcHomePageState();&#10;}&#10;&#10;class _GrpcHomePageState extends State&lt;GrpcHomePage&gt; with WidgetsBindingObserver {&#10;  final GridInteractionController _gridController = GridInteractionController();&#10;  final Logger logger = Logger();&#10;  final ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; _users = ValueNotifier({});&#10;  GrpcUser? _selectedUser;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    WidgetsBinding.instance.addObserver(this);&#10;    WidgetsBinding.instance.addPostFrameCallback((_) {&#10;      _gridController.setInitState(MediaQuery.of(context).size);&#10;    });&#10;    startUserStream();&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    WidgetsBinding.instance.removeObserver(this);&#10;    _users.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  @override&#10;  void didChangeMetrics() {&#10;    setState(() {&#10;      _gridController.clampOffsetAndZoom(MediaQuery.of(context).size);&#10;    });&#10;  }&#10;&#10;  void startUserStream() async {&#10;    var colorIndex = 0;&#10;    while (true) {&#10;      try {&#10;        await for (RealTimeUserResponse userResponse in GrpcClient().trackerClient.getUsers(Empty())) {&#10;          if (userResponse.status == TrackerStatus.OK) {&#10;            final GrpcUser returnedUser = GrpcUser(&#10;              username: userResponse.userName,&#10;              currentX: userResponse.currentLocation.x,&#10;              currentY: userResponse.currentLocation.y,&#10;            );&#10;            returnedUser.color = AppConfig.userColors[colorIndex % AppConfig.userColors.length];&#10;&#10;            if (userResponse.eventType == DynamoDBEvent.INSERT || userResponse.eventType == DynamoDBEvent.EXISTING || userResponse.eventType == DynamoDBEvent.MODIFY) {&#10;              final updatedUsers = Map&lt;String, GrpcUser&gt;.from(_users.value);&#10;              updatedUsers.update(&#10;                userResponse.userName,&#10;                (existing) {&#10;                  logger.info('Updating user ${userResponse.userName} from (${existing.currentX}, ${existing.currentY}]) to (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;                  returnedUser.color = existing.color; // Preserve existing color&#10;                  returnedUser.showPath = existing.showPath; // Preserve path visibility&#10;                  returnedUser.pathToShow = existing.pathToShow; // Preserve path data&#10;                  return returnedUser;&#10;                },&#10;                ifAbsent: () {&#10;                  logger.info('Adding existing user: ${userResponse.userName}] at (${returnedUser.currentX}], ${returnedUser.currentY})');&#10;                  colorIndex++;&#10;                  return returnedUser;&#10;                },&#10;              );&#10;              _users.value = updatedUsers;  // This will trigger the ValueListenable&#10;            } else if(userResponse.eventType == DynamoDBEvent.REMOVE) {&#10;              final updatedUsers = Map&lt;String, GrpcUser&gt;.from(_users.value);&#10;              updatedUsers.remove(userResponse.userName);&#10;              _users.value = updatedUsers;  // This will trigger the ValueListenable&#10;              logger.info('Removed user: ${userResponse.userName}');&#10;            }&#10;&#10;            logger.debug('Current user count: ${_users.value.length}');&#10;          } else {&#10;            logger.warning('Response Status: ${userResponse.status} - ${userResponse.message}');&#10;          }&#10;        }&#10;      } catch (e) {&#10;        logger.error('Stream error: $e');&#10;        await Future.delayed(const Duration(seconds: 5));&#10;        logger.info('Attempting to reconnect to user stream...');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return LayoutBuilder(&#10;        builder: (context, constraints) {&#10;          WidgetsBinding.instance.addPostFrameCallback((_) {&#10;            final size = Size(constraints.maxWidth, constraints.maxHeight);&#10;            setState(() {&#10;              _gridController.clampOffsetAndZoom(size);&#10;            });&#10;          });&#10;          return Scaffold(&#10;            appBar: AppBar(title: Text(widget.title)),&#10;            body: Stack(&#10;              children: [&#10;                // Only the grid area is wrapped with Listener for pointer signals&#10;                Listener(&#10;                  onPointerSignal: (event) {&#10;                    setState(() {&#10;                      _gridController.handlePointerSignal(event, MediaQuery.of(context).size);&#10;                    });&#10;                  },&#10;                  child: GestureDetector(&#10;                    onPanUpdate: (details) {&#10;                      setState(() {&#10;                        _gridController.handleDragUpdate(details, MediaQuery.of(context).size);&#10;                      });&#10;                    },&#10;                    child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                      valueListenable: _users,&#10;                      builder: (context, users, _) {&#10;                        return CustomPaint(&#10;                          size: Size.infinite,&#10;                          painter: CoordinateGridPainter(users, _selectedUser),&#10;                        );&#10;                      },&#10;                    ),&#10;                  ),&#10;                ),&#10;                Positioned(&#10;                  left: 16,&#10;                  top: 16,&#10;                  bottom: 16,&#10;                  child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                    valueListenable: _users,&#10;                    builder: (context, users, _) {&#10;                      return ExistingUsers(&#10;                        users: users,&#10;                        onUserTap: (user) {&#10;                          final size = MediaQuery.of(context).size;&#10;                          setState(() {&#10;                            zoomToUser(_gridController, size, user);&#10;                            _selectedUser = user;&#10;                          });&#10;                        },&#10;                        onTakeTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().takeTrip(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            var path = response.user.pathsTraveled[response.user.pathsTraveled.length - 1];&#10;&#10;                            List&lt;List&lt;double&gt;&gt; pathToAdd = [];&#10;&#10;                            for (var location in path!.pathTraveled) {&#10;                              pathToAdd.add([location.x, location.y]);&#10;                            }&#10;&#10;                            user.addPath(pathToAdd);&#10;&#10;                            GrpcUser pathEndpointUser = GrpcUser(&#10;                              username: user.username,&#10;                              currentX: pathToAdd.last[0],&#10;                              currentY: pathToAdd.last[1],&#10;                            );&#10;&#10;                            logger.info('Trip taken for user: ${user.username} to (${response.user.currentLocation.x}, ${response.user.currentLocation.y})');&#10;                            logger.info('Trip Details: ${user.pathToShow}');&#10;&#10;                            setState(() {&#10;                              _selectedUser = user;&#10;                              user.showPath = true;&#10;&#10;                              // Update user's current position to the end of the path&#10;                              user.currentX = pathToAdd.last[0];&#10;                              user.currentY = pathToAdd.last[1];&#10;&#10;                              // Zoom to the final location&#10;                              zoomToUser(_gridController, MediaQuery.of(context).size, pathEndpointUser);&#10;                            });&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                        onShowLastTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().getUser(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            if (response.user.pathsTraveled.isNotEmpty) {&#10;                              var path = response.user.pathsTraveled[response.user.pathsTraveled.length - 1];&#10;&#10;                              List&lt;List&lt;double&gt;&gt; pathToShow = [];&#10;&#10;                              for (var location in path!.pathTraveled) {&#10;                                pathToShow.add([location.x, location.y]);&#10;                              }&#10;&#10;                              user.pathToShow = pathToShow;&#10;&#10;                              GrpcUser pathEndpointUser = GrpcUser(&#10;                                username: user.username,&#10;                                currentX: pathToShow.last[0],&#10;                                currentY: pathToShow.last[1],&#10;                              );&#10;&#10;                              logger.info('Showing last trip for user: ${user.username}');&#10;                              logger.info('Trip Details: ${user.pathToShow}');&#10;&#10;                              setState(() {&#10;                                _selectedUser = user;&#10;                                user.showPath = true;&#10;&#10;                                // Zoom to the final location&#10;                                zoomToUser(_gridController, MediaQuery.of(context).size, pathEndpointUser);&#10;                              });&#10;                            } else {&#10;                              logger.info('No trips found for user: ${user.username}');&#10;                            }&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                        onMoveUser: (user) =&gt; onMoveUser(&#10;                          context,&#10;                          _gridController,&#10;                          _users,&#10;                          (movedUser) =&gt; setState(() {&#10;                            _selectedUser = movedUser;&#10;                          }),&#10;                          user&#10;                        ),&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;                const Row(&#10;                  children: [&#10;                    Expanded(&#10;                      flex: 2,&#10;                      child: Align(&#10;                        alignment: Alignment.topRight,&#10;                        child: Padding(&#10;                          padding: EdgeInsets.all(16),&#10;                          child: NewUserInput(),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ],&#10;                ),&#10;              ],&#10;            ),&#10;          );&#10;        });&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/controllers/grid_interaction_controller.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../widgets/new_user_input.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../painters/coordinate_grid_painter.dart';&#10;import '../widgets/existing_users.dart';&#10;import '../singletons/app_config.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;import '../listeners/on_move_user.dart';&#10;&#10;class GrpcHomePage extends StatefulWidget {&#10;  const GrpcHomePage({super.key, required this.title});&#10;&#10;  final String title;&#10;&#10;  @override&#10;  State&lt;GrpcHomePage&gt; createState() =&gt; _GrpcHomePageState();&#10;}&#10;&#10;class _GrpcHomePageState extends State&lt;GrpcHomePage&gt; with WidgetsBindingObserver {&#10;  final GridInteractionController _gridController = GridInteractionController();&#10;  final Logger logger = Logger();&#10;  final ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; _users = ValueNotifier({});&#10;  GrpcUser? _selectedUser;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    WidgetsBinding.instance.addObserver(this);&#10;    WidgetsBinding.instance.addPostFrameCallback((_) {&#10;      _gridController.setInitState(MediaQuery.of(context).size);&#10;    });&#10;    startUserStream();&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    WidgetsBinding.instance.removeObserver(this);&#10;    _users.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  @override&#10;  void didChangeMetrics() {&#10;    setState(() {&#10;      _gridController.clampOffsetAndZoom(MediaQuery.of(context).size);&#10;    });&#10;  }&#10;&#10;  void startUserStream() async {&#10;    var colorIndex = 0;&#10;    while (true) {&#10;      try {&#10;        await for (RealTimeUserResponse userResponse in GrpcClient().trackerClient.getUsers(Empty())) {&#10;          if (userResponse.status == TrackerStatus.OK) {&#10;            final GrpcUser returnedUser = GrpcUser(&#10;              username: userResponse.userName,&#10;              currentX: userResponse.currentLocation.x,&#10;              currentY: userResponse.currentLocation.y,&#10;            );&#10;            returnedUser.color = AppConfig.userColors[colorIndex % AppConfig.userColors.length];&#10;&#10;            if (userResponse.eventType == DynamoDBEvent.INSERT || userResponse.eventType == DynamoDBEvent.EXISTING || userResponse.eventType == DynamoDBEvent.MODIFY) {&#10;              final updatedUsers = Map&lt;String, GrpcUser&gt;.from(_users.value);&#10;              updatedUsers.update(&#10;                userResponse.userName,&#10;                (existing) {&#10;                  logger.info('Updating user ${userResponse.userName} from (${existing.currentX}, ${existing.currentY}]) to (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;                  returnedUser.color = existing.color; // Preserve existing color&#10;                  returnedUser.showPath = existing.showPath; // Preserve path visibility&#10;                  returnedUser.pathToShow = existing.pathToShow; // Preserve path data&#10;                  return returnedUser;&#10;                },&#10;                ifAbsent: () {&#10;                  logger.info('Adding existing user: ${userResponse.userName}] at (${returnedUser.currentX}], ${returnedUser.currentY})');&#10;                  colorIndex++;&#10;                  return returnedUser;&#10;                },&#10;              );&#10;              _users.value = updatedUsers;  // This will trigger the ValueListenable&#10;            } else if(userResponse.eventType == DynamoDBEvent.REMOVE) {&#10;              final updatedUsers = Map&lt;String, GrpcUser&gt;.from(_users.value);&#10;              updatedUsers.remove(userResponse.userName);&#10;              _users.value = updatedUsers;  // This will trigger the ValueListenable&#10;              logger.info('Removed user: ${userResponse.userName}');&#10;            }&#10;&#10;            logger.debug('Current user count: ${_users.value.length}');&#10;          } else {&#10;            logger.warning('Response Status: ${userResponse.status} - ${userResponse.message}');&#10;          }&#10;        }&#10;      } catch (e) {&#10;        logger.error('Stream error: $e');&#10;        await Future.delayed(const Duration(seconds: 5));&#10;        logger.info('Attempting to reconnect to user stream...');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return LayoutBuilder(&#10;        builder: (context, constraints) {&#10;          WidgetsBinding.instance.addPostFrameCallback((_) {&#10;            final size = Size(constraints.maxWidth, constraints.maxHeight);&#10;            setState(() {&#10;              _gridController.clampOffsetAndZoom(size);&#10;            });&#10;          });&#10;          return Scaffold(&#10;            appBar: AppBar(title: Text(widget.title)),&#10;            body: Stack(&#10;              children: [&#10;                // Only the grid area is wrapped with Listener for pointer signals&#10;                Listener(&#10;                  onPointerSignal: (event) {&#10;                    setState(() {&#10;                      _gridController.handlePointerSignal(event, MediaQuery.of(context).size);&#10;                    });&#10;                  },&#10;                  child: GestureDetector(&#10;                    onPanUpdate: (details) {&#10;                      setState(() {&#10;                        _gridController.handleDragUpdate(details, MediaQuery.of(context).size);&#10;                      });&#10;                    },&#10;                    child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                      valueListenable: _users,&#10;                      builder: (context, users, _) {&#10;                        return CustomPaint(&#10;                          size: Size.infinite,&#10;                          painter: CoordinateGridPainter(users, _selectedUser),&#10;                        );&#10;                      },&#10;                    ),&#10;                  ),&#10;                ),&#10;                Positioned(&#10;                  left: 16,&#10;                  top: 16,&#10;                  bottom: 16,&#10;                  child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                    valueListenable: _users,&#10;                    builder: (context, users, _) {&#10;                      return ExistingUsers(&#10;                        users: users,&#10;                        onUserTap: (user) {&#10;                          final size = MediaQuery.of(context).size;&#10;                          setState(() {&#10;                            zoomToUser(_gridController, size, user);&#10;                            _selectedUser = user;&#10;                          });&#10;                        },&#10;                        onTakeTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().takeTrip(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            var path = response.user.pathsTraveled[response.user.pathsTraveled.length - 1];&#10;&#10;                            List&lt;List&lt;double&gt;&gt; pathToAdd = [];&#10;&#10;                            for (var location in path!.pathTraveled) {&#10;                              pathToAdd.add([location.x, location.y]);&#10;                            }&#10;&#10;                            user.addPath(pathToAdd);&#10;&#10;                            GrpcUser pathEndpointUser = GrpcUser(&#10;                              username: user.username,&#10;                              currentX: pathToAdd.last[0],&#10;                              currentY: pathToAdd.last[1],&#10;                            );&#10;&#10;                            logger.info('Trip taken for user: ${user.username} to (${response.user.currentLocation.x}, ${response.user.currentLocation.y})');&#10;                            logger.info('Trip Details: ${user.pathToShow}');&#10;&#10;                            setState(() {&#10;                              _selectedUser = user;&#10;                              user.showPath = true;&#10;&#10;                              // Update user's current position to the end of the path&#10;                              user.currentX = pathToAdd.last[0];&#10;                              user.currentY = pathToAdd.last[1];&#10;&#10;                              // Zoom to the final location&#10;                              zoomToUser(_gridController, MediaQuery.of(context).size, pathEndpointUser);&#10;                            });&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                        onShowLastTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().getUser(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            if (response.user.pathsTraveled.isNotEmpty) {&#10;                              var path = response.user.pathsTraveled[response.user.pathsTraveled.length - 1];&#10;&#10;                              List&lt;List&lt;double&gt;&gt; pathToShow = [];&#10;&#10;                              for (var location in path!.pathTraveled) {&#10;                                pathToShow.add([location.x, location.y]);&#10;                              }&#10;&#10;                              user.pathToShow = pathToShow;&#10;&#10;                              GrpcUser pathEndpointUser = GrpcUser(&#10;                                username: user.username,&#10;                                currentX: pathToShow.last[0],&#10;                                currentY: pathToShow.last[1],&#10;                              );&#10;&#10;                              logger.info('Showing last trip for user: ${user.username}');&#10;                              logger.info('Trip Details: ${user.pathToShow}');&#10;&#10;                              setState(() {&#10;                                _selectedUser = user;&#10;                                user.showPath = true;&#10;&#10;                                // Zoom to the final location&#10;                                zoomToUser(_gridController, MediaQuery.of(context).size, pathEndpointUser);&#10;                              });&#10;                            } else {&#10;                              logger.info('No trips found for user: ${user.username}');&#10;                            }&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                        onMoveUser: (user) =&gt; onMoveUser(&#10;                          context,&#10;                          _gridController,&#10;                          _users,&#10;                          (movedUser) =&gt; setState(() {&#10;                            _selectedUser = movedUser;&#10;                          }),&#10;                          user&#10;                        ),&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;                const Row(&#10;                  children: [&#10;                    Expanded(&#10;                      flex: 2,&#10;                      child: Align(&#10;                        alignment: Alignment.topRight,&#10;                        child: Padding(&#10;                          padding: EdgeInsets.all(16),&#10;                          child: NewUserInput(),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ],&#10;                ),&#10;              ],&#10;            ),&#10;          );&#10;        });&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>