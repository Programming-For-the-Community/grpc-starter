<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/client/lib/pages/grpc_home.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/pages/grpc_home.dart" />
              <option name="originalContent" value="import 'package:flutter/gestures.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/controllers/grid_interaction_controller.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../widgets/new_user_input.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../painters/coordinate_grid_painter.dart';&#10;import '../widgets/existing_users.dart';&#10;import '../singletons/app_config.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;&#10;class GrpcHomePage extends StatefulWidget {&#10;  const GrpcHomePage({super.key, required this.title});&#10;&#10;  final String title;&#10;&#10;  @override&#10;  State&lt;GrpcHomePage&gt; createState() =&gt; _GrpcHomePageState();&#10;}&#10;&#10;class _GrpcHomePageState extends State&lt;GrpcHomePage&gt; with WidgetsBindingObserver {&#10;  final GridInteractionController _gridController = GridInteractionController();&#10;  final Logger logger = Logger();&#10;  final ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; _users = ValueNotifier({});&#10;  GrpcUser? _selectedUser;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    WidgetsBinding.instance.addObserver(this);&#10;    WidgetsBinding.instance.addPostFrameCallback((_) {&#10;      _gridController.setInitState(MediaQuery.of(context).size);&#10;    });&#10;    startUserStream();&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    WidgetsBinding.instance.removeObserver(this);&#10;    _users.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  @override&#10;  void didChangeMetrics() {&#10;    setState(() {&#10;      _gridController.clampOffsetAndZoom(MediaQuery.of(context).size);&#10;    });&#10;  }&#10;&#10;  void startUserStream() async {&#10;    var colorIndex = 0;&#10;    while (true) {&#10;      try {&#10;        await for (RealTimeUserResponse userResponse in GrpcClient().trackerClient.getUsers(Empty())) {&#10;          if (userResponse.status == TrackerStatus.OK) {&#10;            final GrpcUser returnedUser = GrpcUser(&#10;              username: userResponse.userName,&#10;              currentX: userResponse.currentLocation.x,&#10;              currentY: userResponse.currentLocation.y,&#10;            );&#10;            returnedUser.color = AppConfig.userColors[colorIndex % AppConfig.userColors.length];&#10;&#10;            if (userResponse.eventType == DynamoDBEvent.INSERT) {&#10;              _users.value[userResponse.userName] = returnedUser;&#10;              colorIndex++;&#10;              logger.info('New user added: ${userResponse.userName} at (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;            } else if (userResponse.eventType == DynamoDBEvent.EXISTING || userResponse.eventType == DynamoDBEvent.MODIFY) {&#10;              _users.value.update(&#10;                userResponse.userName,&#10;                (existing) {&#10;                  logger.info('Updating user ${userResponse.userName} from (${existing.currentX}, ${existing.currentY}]) to (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;                  returnedUser.color = existing.color; // Preserve existing color&#10;                  return returnedUser;&#10;                },&#10;                ifAbsent: () {&#10;                  logger.info('Adding existing user: ${userResponse.userName}] at (${returnedUser.currentX}], ${returnedUser.currentY})');&#10;                  colorIndex++;&#10;                  return returnedUser;&#10;                },&#10;              );&#10;            } else if(userResponse.eventType == DynamoDBEvent.REMOVE) {&#10;              _users.value.remove(userResponse.userName);&#10;              logger.info('Removed user: ${userResponse.userName}');&#10;            }&#10;            logger.debug('Current user count: ${_users.value.length}');&#10;            _users.notifyListeners();&#10;          } else {&#10;            logger.warning('Response Status: ${userResponse.status} - ${userResponse.message}');&#10;          }&#10;        }&#10;      } catch (e) {&#10;        logger.error('Stream error: $e');&#10;        await Future.delayed(const Duration(seconds: 5));&#10;        logger.info('Attempting to reconnect to user stream...');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return LayoutBuilder(&#10;        builder: (context, constraints) {&#10;          WidgetsBinding.instance.addPostFrameCallback((_) {&#10;            final size = Size(constraints.maxWidth, constraints.maxHeight);&#10;            setState(() {&#10;              _gridController.clampOffsetAndZoom(size);&#10;            });&#10;          });&#10;          return Scaffold(&#10;            appBar: AppBar(title: Text(widget.title)),&#10;            body: Stack(&#10;              children: [&#10;                // Only the grid area is wrapped with Listener for pointer signals&#10;                Listener(&#10;                  onPointerSignal: (event) {&#10;                    setState(() {&#10;                      _gridController.handlePointerSignal(event, MediaQuery.of(context).size);&#10;                    });&#10;                  },&#10;                  child: GestureDetector(&#10;                    onPanUpdate: (details) {&#10;                      setState(() {&#10;                        _gridController.handleDragUpdate(details, MediaQuery.of(context).size);&#10;                      });&#10;                    },&#10;                    child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                      valueListenable: _users,&#10;                      builder: (context, users, _) {&#10;                        return CustomPaint(&#10;                          size: Size.infinite,&#10;                          painter: CoordinateGridPainter(users, _selectedUser),&#10;                        );&#10;                      },&#10;                    ),&#10;                  ),&#10;                ),&#10;                Positioned(&#10;                  left: 16,&#10;                  top: 16,&#10;                  bottom: 16,&#10;                  child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                    valueListenable: _users,&#10;                    builder: (context, users, _) {&#10;                      return ExistingUsers(&#10;                        users: users,&#10;                        onUserTap: (user) {&#10;                          final size = MediaQuery.of(context).size;&#10;                          setState(() {&#10;                            zoomToUser(_gridController, size, user);&#10;                            _selectedUser = user;&#10;                          });&#10;                        },&#10;                        onTakeTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().takeTrip(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            logger.info('Trip taken for user: ${user.username} to (${response.user.currentLocation.x}, ${response.user.currentLocation.y})');&#10;                            logger.info('Trip Details: ${response.user.pathsTraveled[response.user.pathsTraveled.length - 1]}');&#10;                            setState(() {&#10;                              _selectedUser = user;&#10;                              user.showPath = true;&#10;                            });&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;                const Row(&#10;                  children: [&#10;                    Expanded(&#10;                      flex: 2,&#10;                      child: Align(&#10;                        alignment: Alignment.topRight,&#10;                        child: Padding(&#10;                          padding: EdgeInsets.all(16),&#10;                          child: NewUserInput(),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ],&#10;                ),&#10;              ],&#10;            ),&#10;          );&#10;        });&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/gestures.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/controllers/grid_interaction_controller.dart';&#10;&#10;import '../singletons/logger.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../widgets/new_user_input.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../painters/coordinate_grid_painter.dart';&#10;import '../widgets/existing_users.dart';&#10;import '../singletons/app_config.dart';&#10;import '../helpers/zoom_to_user.dart';&#10;&#10;class GrpcHomePage extends StatefulWidget {&#10;  const GrpcHomePage({super.key, required this.title});&#10;&#10;  final String title;&#10;&#10;  @override&#10;  State&lt;GrpcHomePage&gt; createState() =&gt; _GrpcHomePageState();&#10;}&#10;&#10;class _GrpcHomePageState extends State&lt;GrpcHomePage&gt; with WidgetsBindingObserver {&#10;  final GridInteractionController _gridController = GridInteractionController();&#10;  final Logger logger = Logger();&#10;  final ValueNotifier&lt;Map&lt;String, GrpcUser&gt;&gt; _users = ValueNotifier({});&#10;  GrpcUser? _selectedUser;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    WidgetsBinding.instance.addObserver(this);&#10;    WidgetsBinding.instance.addPostFrameCallback((_) {&#10;      _gridController.setInitState(MediaQuery.of(context).size);&#10;    });&#10;    startUserStream();&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    WidgetsBinding.instance.removeObserver(this);&#10;    _users.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  @override&#10;  void didChangeMetrics() {&#10;    setState(() {&#10;      _gridController.clampOffsetAndZoom(MediaQuery.of(context).size);&#10;    });&#10;  }&#10;&#10;  void startUserStream() async {&#10;    var colorIndex = 0;&#10;    while (true) {&#10;      try {&#10;        await for (RealTimeUserResponse userResponse in GrpcClient().trackerClient.getUsers(Empty())) {&#10;          if (userResponse.status == TrackerStatus.OK) {&#10;            final GrpcUser returnedUser = GrpcUser(&#10;              username: userResponse.userName,&#10;              currentX: userResponse.currentLocation.x,&#10;              currentY: userResponse.currentLocation.y,&#10;            );&#10;            returnedUser.color = AppConfig.userColors[colorIndex % AppConfig.userColors.length];&#10;&#10;            if (userResponse.eventType == DynamoDBEvent.INSERT) {&#10;              _users.value[userResponse.userName] = returnedUser;&#10;              colorIndex++;&#10;              logger.info('New user added: ${userResponse.userName} at (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;            } else if (userResponse.eventType == DynamoDBEvent.EXISTING || userResponse.eventType == DynamoDBEvent.MODIFY) {&#10;              _users.value.update(&#10;                userResponse.userName,&#10;                (existing) {&#10;                  logger.info('Updating user ${userResponse.userName} from (${existing.currentX}, ${existing.currentY}]) to (${returnedUser.currentX}, ${returnedUser.currentY})');&#10;                  returnedUser.color = existing.color; // Preserve existing color&#10;                  return returnedUser;&#10;                },&#10;                ifAbsent: () {&#10;                  logger.info('Adding existing user: ${userResponse.userName}] at (${returnedUser.currentX}], ${returnedUser.currentY})');&#10;                  colorIndex++;&#10;                  return returnedUser;&#10;                },&#10;              );&#10;            } else if(userResponse.eventType == DynamoDBEvent.REMOVE) {&#10;              _users.value.remove(userResponse.userName);&#10;              logger.info('Removed user: ${userResponse.userName}');&#10;            }&#10;            logger.debug('Current user count: ${_users.value.length}');&#10;            _users.notifyListeners();&#10;          } else {&#10;            logger.warning('Response Status: ${userResponse.status} - ${userResponse.message}');&#10;          }&#10;        }&#10;      } catch (e) {&#10;        logger.error('Stream error: $e');&#10;        await Future.delayed(const Duration(seconds: 5));&#10;        logger.info('Attempting to reconnect to user stream...');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return LayoutBuilder(&#10;        builder: (context, constraints) {&#10;          WidgetsBinding.instance.addPostFrameCallback((_) {&#10;            final size = Size(constraints.maxWidth, constraints.maxHeight);&#10;            setState(() {&#10;              _gridController.clampOffsetAndZoom(size);&#10;            });&#10;          });&#10;          return Scaffold(&#10;            appBar: AppBar(title: Text(widget.title)),&#10;            body: Stack(&#10;              children: [&#10;                // Only the grid area is wrapped with Listener for pointer signals&#10;                Listener(&#10;                  onPointerSignal: (event) {&#10;                    setState(() {&#10;                      _gridController.handlePointerSignal(event, MediaQuery.of(context).size);&#10;                    });&#10;                  },&#10;                  child: GestureDetector(&#10;                    onPanUpdate: (details) {&#10;                      setState(() {&#10;                        _gridController.handleDragUpdate(details, MediaQuery.of(context).size);&#10;                      });&#10;                    },&#10;                    child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                      valueListenable: _users,&#10;                      builder: (context, users, _) {&#10;                        return CustomPaint(&#10;                          size: Size.infinite,&#10;                          painter: CoordinateGridPainter(users, _selectedUser),&#10;                        );&#10;                      },&#10;                    ),&#10;                  ),&#10;                ),&#10;                Positioned(&#10;                  left: 16,&#10;                  top: 16,&#10;                  bottom: 16,&#10;                  child: ValueListenableBuilder&lt;Map&lt;String, GrpcUser&gt;&gt;(&#10;                    valueListenable: _users,&#10;                    builder: (context, users, _) {&#10;                      return ExistingUsers(&#10;                        users: users,&#10;                        onUserTap: (user) {&#10;                          final size = MediaQuery.of(context).size;&#10;                          setState(() {&#10;                            zoomToUser(_gridController, size, user);&#10;                            _selectedUser = user;&#10;                          });&#10;                        },&#10;                        onTakeTrip: (user) async {&#10;                          UserResponse response = await GrpcClient().takeTrip(user.username);&#10;&#10;                          if (response.status == TrackerStatus.OK) {&#10;                            logger.info('Trip taken for user: ${user.username} to (${response.user.currentLocation.x}, ${response.user.currentLocation.y})');&#10;                            logger.info('Trip Details: ${response.user.pathsTraveled[response.user.pathsTraveled.length - 1]}');&#10;                            setState(() {&#10;                              _selectedUser = user;&#10;                              user.showPath = true;&#10;                            });&#10;                          } else {&#10;                            logger.warning('Response Status: ${response.status} - ${response.message}');&#10;                          }&#10;                        },&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;                const Row(&#10;                  children: [&#10;                    Expanded(&#10;                      flex: 2,&#10;                      child: Align(&#10;                        alignment: Alignment.topRight,&#10;                        child: Padding(&#10;                          padding: EdgeInsets.all(16),&#10;                          child: NewUserInput(),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ],&#10;                ),&#10;              ],&#10;            ),&#10;          );&#10;        });&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/client/lib/painters/coordinate_grid_painter.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/painters/coordinate_grid_painter.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/helpers/draw_user_bubble.dart';&#10;&#10;import '../controllers/grid_interaction_controller.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class CoordinateGridPainter extends CustomPainter {&#10;  final Map&lt;String, GrpcUser&gt; users;&#10;  final GrpcUser? selectedUser;&#10;  final gridController = GridInteractionController();&#10;  AppConfig appConfig = AppConfig();&#10;&#10;  CoordinateGridPainter(this.users, this.selectedUser);&#10;&#10;  @override&#10;  void paint(Canvas canvas, Size size) {&#10;    canvas.save();&#10;    canvas.translate(gridController.getOffset().dx, gridController.getOffset().dy);&#10;    canvas.scale(gridController.getZoom());&#10;&#10;    // Paint for regular grid lines&#10;    final minorGridlinePaint = Paint()&#10;      ..color = Colors.grey&#10;      ..strokeWidth = appConfig.minorGridlineWidth;&#10;&#10;    // Paint for darker grid lines every 200 units&#10;    final majorGridlinePaint = Paint()&#10;&#10;      ..color = Colors.grey[700]!&#10;      ..strokeWidth = appConfig.majorGridlineWidth;&#10;&#10;    // Paint for origin crosshairs&#10;    final originPaint = Paint()&#10;      ..color = Colors.black&#10;      ..strokeWidth = appConfig.originWidth;&#10;&#10;    // Draw vertical grid lines&#10;    for (double x = appConfig.minGridSize; x &lt;= appConfig.maxGridSize; x += appConfig.minorGridlineSpacing) {&#10;      final paint = (x % appConfig.majorGridlineSpacing == 0) ? majorGridlinePaint : minorGridlinePaint;&#10;      canvas.drawLine(&#10;        Offset(x, appConfig.minGridSize),&#10;        Offset(x, appConfig.maxGridSize),&#10;        paint,&#10;      );&#10;    }&#10;&#10;    // Draw horizontal grid lines (invert y-axis)&#10;    for (double y = appConfig.minGridSize; y &lt;= appConfig.maxGridSize; y += appConfig.minorGridlineSpacing) {&#10;      final paint = (y % appConfig.majorGridlineSpacing == 0) ? majorGridlinePaint : minorGridlinePaint;&#10;      canvas.drawLine(&#10;        Offset(appConfig.minGridSize, -y),&#10;        Offset(appConfig.maxGridSize, -y),&#10;        paint,&#10;      );&#10;    }&#10;&#10;    // Draw origin crosshairs&#10;    canvas.drawLine(&#10;      Offset(0, appConfig.minGridSize),&#10;      Offset(0, appConfig.maxGridSize),&#10;      originPaint,&#10;    );&#10;    canvas.drawLine(&#10;      Offset(appConfig.minGridSize, 0),&#10;      Offset(appConfig.maxGridSize, 0),&#10;      originPaint,&#10;    );&#10;&#10;    // Draw user locations&#10;    users.values.forEach( (user) {&#10;      if(user.username != selectedUser!.username &amp;&amp; user.showPath) { user.showPath = false; } // Ensure that we are only going to show the path for the selected user&#10;&#10;      Offset userOffset = Offset(&#10;        user.currentX,&#10;        -user.currentY, // Invert y-axis&#10;      );&#10;      Paint userPaint = Paint()&#10;        ..color = user.color&#10;        ..style = PaintingStyle.fill;&#10;&#10;      // Draw the path if showPath is true and user has paths&#10;      if (user.showPath &amp;&amp; user.pathsTraveled.isNotEmpty) {&#10;        final lastPathId = user.pathsTraveled.keys.reduce((a, b) =&gt; a &gt; b ? a : b);&#10;        final lastPath = user.pathsTraveled[lastPathId];&#10;        &#10;        if (lastPath != null &amp;&amp; lastPath.isNotEmpty) {&#10;          // Draw the smooth path&#10;          Paint pathPaint = Paint()&#10;            ..color = user.color.withOpacity(0.6)&#10;            ..strokeWidth = 2.0&#10;            ..style = PaintingStyle.stroke;&#10;&#10;          // Create a smooth path using cubic bezier curves&#10;          Path tripPath = Path();&#10;          if (lastPath.length &gt;= 2) {&#10;            List&lt;Offset&gt; points = lastPath&#10;                .where((point) =&gt; point.length &gt;= 2)&#10;                .map((point) =&gt; Offset(point[0], -point[1]))&#10;                .toList();&#10;&#10;            // Start at the first point&#10;            tripPath.moveTo(points.first.dx, points.first.dy);&#10;&#10;            // If we only have 2 points, draw a straight line&#10;            if (points.length == 2) {&#10;              tripPath.lineTo(points.last.dx, points.last.dy);&#10;            } else {&#10;              // For more than 2 points, create a smooth curve&#10;              for (int i = 0; i &lt; points.length - 2; i++) {&#10;                final p0 = points[i];&#10;                final p1 = points[i + 1];&#10;                final p2 = points[i + 2];&#10;&#10;                // Calculate control points for smooth curve&#10;                final controlPoint1 = Offset(&#10;                  p0.dx + (p1.dx - p0.dx) * 0.5,&#10;                  p0.dy + (p1.dy - p0.dy) * 0.5,&#10;                );&#10;                final controlPoint2 = Offset(&#10;                  p1.dx + (p2.dx - p1.dx) * 0.5,&#10;                  p1.dy + (p2.dy - p1.dy) * 0.5,&#10;                );&#10;&#10;                tripPath.cubicTo(&#10;                  controlPoint1.dx, controlPoint1.dy,&#10;                  controlPoint2.dx, controlPoint2.dy,&#10;                  p1.dx, p1.dy,&#10;                );&#10;&#10;                // If this is the second-to-last iteration, connect to the final point&#10;                if (i == points.length - 3) {&#10;                  tripPath.lineTo(points.last.dx, points.last.dy);&#10;                }&#10;              }&#10;            }&#10;&#10;            // Draw the path&#10;            canvas.drawPath(tripPath, pathPaint);&#10;&#10;            // Draw direction arrows along the smooth path&#10;            for (int i = 0; i &lt; points.length - 1; i += 2) {&#10;              if (i + 1 &lt; points.length) {&#10;                drawArrow(&#10;                  canvas,&#10;                  points[i],&#10;                  points[i + 1],&#10;                  user.color.withOpacity(0.8)&#10;                );&#10;              }&#10;            }&#10;&#10;            // Draw start and end point dots&#10;            Paint endPointPaint = Paint()&#10;              ..color = user.color&#10;              ..style = PaintingStyle.fill;&#10;&#10;            // Start point (larger, more transparent)&#10;            canvas.drawCircle(&#10;              points.first,&#10;              appConfig.userDotRadius * 1.5,&#10;              endPointPaint..color = user.color.withOpacity(0.4)&#10;            );&#10;&#10;            // End point (normal size, solid)&#10;            canvas.drawCircle(&#10;              points.last,&#10;              appConfig.userDotRadius,&#10;              endPointPaint..color = user.color&#10;            );&#10;&#10;            // If this is the selected user, zoom to the final location&#10;            if (selectedUser != null &amp;&amp; user.username == selectedUser!.username) {&#10;              final lastPoint = lastPath.last;&#10;              if (lastPoint.length &gt;= 2) {&#10;                zoomToUser(gridController, size, user);&#10;              }&#10;            }&#10;          }&#10;        }&#10;      }&#10;&#10;      canvas.drawCircle(userOffset, appConfig.userDotRadius, userPaint);&#10;&#10;      if (selectedUser != null &amp;&amp; user.username == selectedUser!.username) {&#10;        drawUserBubble(canvas, userOffset, user);&#10;      }&#10;    });&#10;&#10;    canvas.restore();&#10;  }&#10;&#10;  @override&#10;  bool shouldRepaint(CustomPainter oldDelegate) =&gt; true;&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_grpc_client/helpers/draw_user_bubble.dart';&#10;&#10;import '../controllers/grid_interaction_controller.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class CoordinateGridPainter extends CustomPainter {&#10;  final Map&lt;String, GrpcUser&gt; users;&#10;  final GrpcUser? selectedUser;&#10;  final gridController = GridInteractionController();&#10;  AppConfig appConfig = AppConfig();&#10;&#10;  CoordinateGridPainter(this.users, this.selectedUser);&#10;&#10;  @override&#10;  void paint(Canvas canvas, Size size) {&#10;    canvas.save();&#10;    canvas.translate(gridController.getOffset().dx, gridController.getOffset().dy);&#10;    canvas.scale(gridController.getZoom());&#10;&#10;    // Paint for regular grid lines&#10;    final minorGridlinePaint = Paint()&#10;      ..color = Colors.grey&#10;      ..strokeWidth = appConfig.minorGridlineWidth;&#10;&#10;    // Paint for darker grid lines every 200 units&#10;    final majorGridlinePaint = Paint()&#10;&#10;      ..color = Colors.grey[700]!&#10;      ..strokeWidth = appConfig.majorGridlineWidth;&#10;&#10;    // Paint for origin crosshairs&#10;    final originPaint = Paint()&#10;      ..color = Colors.black&#10;      ..strokeWidth = appConfig.originWidth;&#10;&#10;    // Draw vertical grid lines&#10;    for (double x = appConfig.minGridSize; x &lt;= appConfig.maxGridSize; x += appConfig.minorGridlineSpacing) {&#10;      final paint = (x % appConfig.majorGridlineSpacing == 0) ? majorGridlinePaint : minorGridlinePaint;&#10;      canvas.drawLine(&#10;        Offset(x, appConfig.minGridSize),&#10;        Offset(x, appConfig.maxGridSize),&#10;        paint,&#10;      );&#10;    }&#10;&#10;    // Draw horizontal grid lines (invert y-axis)&#10;    for (double y = appConfig.minGridSize; y &lt;= appConfig.maxGridSize; y += appConfig.minorGridlineSpacing) {&#10;      final paint = (y % appConfig.majorGridlineSpacing == 0) ? majorGridlinePaint : minorGridlinePaint;&#10;      canvas.drawLine(&#10;        Offset(appConfig.minGridSize, -y),&#10;        Offset(appConfig.maxGridSize, -y),&#10;        paint,&#10;      );&#10;    }&#10;&#10;    // Draw origin crosshairs&#10;    canvas.drawLine(&#10;      Offset(0, appConfig.minGridSize),&#10;      Offset(0, appConfig.maxGridSize),&#10;      originPaint,&#10;    );&#10;    canvas.drawLine(&#10;      Offset(appConfig.minGridSize, 0),&#10;      Offset(appConfig.maxGridSize, 0),&#10;      originPaint,&#10;    );&#10;&#10;    // Draw user locations&#10;    users.values.forEach( (user) {&#10;      if(user.username != selectedUser!.username &amp;&amp; user.showPath) { user.showPath = false; } // Ensure that we are only going to show the path for the selected user&#10;&#10;      Offset userOffset = Offset(&#10;        user.currentX,&#10;        -user.currentY, // Invert y-axis&#10;      );&#10;      Paint userPaint = Paint()&#10;        ..color = user.color&#10;        ..style = PaintingStyle.fill;&#10;&#10;      // Draw the path if showPath is true and user has paths&#10;      if (user.showPath &amp;&amp; user.pathsTraveled.isNotEmpty) {&#10;        final lastPathId = user.pathsTraveled.keys.reduce((a, b) =&gt; a &gt; b ? a : b);&#10;        final lastPath = user.pathsTraveled[lastPathId];&#10;        &#10;        if (lastPath != null &amp;&amp; lastPath.isNotEmpty) {&#10;          // Draw the smooth path&#10;          Paint pathPaint = Paint()&#10;            ..color = user.color.withOpacity(0.6)&#10;            ..strokeWidth = 2.0&#10;            ..style = PaintingStyle.stroke;&#10;&#10;          // Create a smooth path using cubic bezier curves&#10;          Path tripPath = Path();&#10;          if (lastPath.length &gt;= 2) {&#10;            List&lt;Offset&gt; points = lastPath&#10;                .where((point) =&gt; point.length &gt;= 2)&#10;                .map((point) =&gt; Offset(point[0], -point[1]))&#10;                .toList();&#10;&#10;            // Start at the first point&#10;            tripPath.moveTo(points.first.dx, points.first.dy);&#10;&#10;            // If we only have 2 points, draw a straight line&#10;            if (points.length == 2) {&#10;              tripPath.lineTo(points.last.dx, points.last.dy);&#10;            } else {&#10;              // For more than 2 points, create a smooth curve&#10;              for (int i = 0; i &lt; points.length - 2; i++) {&#10;                final p0 = points[i];&#10;                final p1 = points[i + 1];&#10;                final p2 = points[i + 2];&#10;&#10;                // Calculate control points for smooth curve&#10;                final controlPoint1 = Offset(&#10;                  p0.dx + (p1.dx - p0.dx) * 0.5,&#10;                  p0.dy + (p1.dy - p0.dy) * 0.5,&#10;                );&#10;                final controlPoint2 = Offset(&#10;                  p1.dx + (p2.dx - p1.dx) * 0.5,&#10;                  p1.dy + (p2.dy - p1.dy) * 0.5,&#10;                );&#10;&#10;                tripPath.cubicTo(&#10;                  controlPoint1.dx, controlPoint1.dy,&#10;                  controlPoint2.dx, controlPoint2.dy,&#10;                  p1.dx, p1.dy,&#10;                );&#10;&#10;                // If this is the second-to-last iteration, connect to the final point&#10;                if (i == points.length - 3) {&#10;                  tripPath.lineTo(points.last.dx, points.last.dy);&#10;                }&#10;              }&#10;            }&#10;&#10;            // Draw the path&#10;            canvas.drawPath(tripPath, pathPaint);&#10;&#10;            // Draw direction arrows along the smooth path&#10;            for (int i = 0; i &lt; points.length - 1; i += 2) {&#10;              if (i + 1 &lt; points.length) {&#10;                drawArrow(&#10;                  canvas,&#10;                  points[i],&#10;                  points[i + 1],&#10;                  user.color.withOpacity(0.8)&#10;                );&#10;              }&#10;            }&#10;&#10;            // Draw start and end point dots&#10;            Paint endPointPaint = Paint()&#10;              ..color = user.color&#10;              ..style = PaintingStyle.fill;&#10;&#10;            // Start point (larger, more transparent)&#10;            canvas.drawCircle(&#10;              points.first,&#10;              appConfig.userDotRadius * 1.5,&#10;              endPointPaint..color = user.color.withOpacity(0.4)&#10;            );&#10;&#10;            // End point (normal size, solid)&#10;            canvas.drawCircle(&#10;              points.last,&#10;              appConfig.userDotRadius,&#10;              endPointPaint..color = user.color&#10;            );&#10;&#10;            // If this is the selected user, zoom to the final location&#10;            if (selectedUser != null &amp;&amp; user.username == selectedUser!.username) {&#10;              final lastPoint = lastPath.last;&#10;              if (lastPoint.length &gt;= 2) {&#10;                zoomToUser(gridController, size, user);&#10;              }&#10;            }&#10;          }&#10;        }&#10;      }&#10;&#10;      canvas.drawCircle(userOffset, appConfig.userDotRadius, userPaint);&#10;&#10;      if (selectedUser != null &amp;&amp; user.username == selectedUser!.username) {&#10;        drawUserBubble(canvas, userOffset, user);&#10;      }&#10;    });&#10;&#10;    canvas.restore();&#10;  }&#10;&#10;  @override&#10;  bool shouldRepaint(CustomPainter oldDelegate) =&gt; true;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/client/lib/singletons/app_config.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/singletons/app_config.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_dotenv/flutter_dotenv.dart';&#10;&#10;class AppConfig {&#10;  static final AppConfig _instance = AppConfig._internal();&#10;&#10;  late final String appName;&#10;  late final String appVersion;&#10;  late final String appEnv;&#10;&#10;  late final double maxGridSize;&#10;  late final double minGridSize;&#10;  late final double majorGridlineSpacing;&#10;  late final double majorGridlineWidth;&#10;  late final double minorGridlineSpacing;&#10;  late final double minorGridlineWidth;&#10;  late final double originWidth;&#10;&#10;  late final double bubbleWidth;&#10;  late final double bubbleHeight;&#10;  late final double bubblePadding;&#10;  late final double bubbleOpacity;&#10;  late final double bubbleCornerRadius;&#10;  late final double bubbleBorderWidth;&#10;  late final double bubbleFontSize;&#10;&#10;  late final double tailWidth;&#10;  late final double tailHeight;&#10;  late final double tailShadowElevation;&#10;&#10;  late final double userDotRadius;&#10;&#10;  late final double usersListButtonWidth;&#10;  late final double usersListButtonHeight;&#10;  late final int usersListButtonFontSize;&#10;&#10;  late final String fontFamily;&#10;&#10;  late final String grpcHost;&#10;  late final int grpcPort;&#10;  late final bool grpcSecure;&#10;&#10;  static const List&lt;Color&gt; userColors = [&#10;    Colors.red,&#10;    Colors.blue,&#10;    Colors.green,&#10;    Colors.orange,&#10;    Colors.purple,&#10;    Colors.yellow,&#10;    Colors.cyan,&#10;    Colors.pink,&#10;    Colors.teal,&#10;    Colors.lime,&#10;  ];&#10;&#10;  AppConfig._internal();&#10;&#10;  factory AppConfig() =&gt; _instance;&#10;&#10;  static Future&lt;void&gt; load() async {&#10;    const envPath = String.fromEnvironment('ENV_PATH');&#10;&#10;    await dotenv.load(fileName: envPath.isNotEmpty ? envPath : '.env');&#10;&#10;    // App Settings&#10;    _instance.appName = dotenv.env['APP_NAME'] ?? 'flutter-grpc-client';&#10;    _instance.appVersion = dotenv.env['APP_VERSION'] ?? '1.0.0';&#10;    _instance.appEnv = dotenv.env['APP_ENV'] ?? 'localhost';&#10;&#10;    // UI Settings&#10;    _instance.maxGridSize = double.tryParse(dotenv.env['MAX_GRID_SIZE'] ?? '10000.0') ?? 10000.0;&#10;    _instance.minGridSize = double.tryParse(dotenv.env['MIN_GRID_SIZE'] ?? '-10000.0') ?? -10000.0;&#10;    _instance.majorGridlineSpacing = double.tryParse(dotenv.env['MAJOR_GRIDLINE_SPACING'] ?? '200') ?? 200.0;&#10;    _instance.majorGridlineWidth = double.tryParse(dotenv.env['MAJOR_GRIDLINE_WIDTH'] ?? '1.0') ?? 1.0;&#10;    _instance.minorGridlineSpacing = double.tryParse(dotenv.env['MINOR_GRIDLINE_SPACING'] ?? '10') ?? 10.0;&#10;    _instance.minorGridlineWidth = double.tryParse(dotenv.env['MINOR_GRIDLINE_WIDTH'] ?? '0.5') ?? 0.5;&#10;    _instance.originWidth = double.tryParse(dotenv.env['ORIGIN_WIDTH'] ?? '2.0') ?? 2.0;&#10;&#10;    _instance.bubbleWidth = double.tryParse(dotenv.env['BUBBLE_WIDTH'] ?? '140') ?? 140.0;&#10;    _instance.bubbleHeight = double.tryParse(dotenv.env['BUBBLE_HEIGHT'] ?? '44') ?? 44.0;&#10;    _instance.bubblePadding = double.tryParse(dotenv.env['BUBBLE_PADDING'] ?? '12') ?? 12.0;&#10;    _instance.bubbleOpacity = double.tryParse(dotenv.env['BUBBLE_OPACITY'] ?? '0.85') ?? 0.85;&#10;    _instance.bubbleCornerRadius = double.tryParse(dotenv.env['BUBBLE_CORNER_RADIUS'] ?? '18') ?? 18.0;&#10;    _instance.bubbleBorderWidth = double.tryParse(dotenv.env['BUBBLE_BORDER_WIDTH'] ?? '1.5') ?? 1.5;&#10;    _instance.bubbleFontSize = double.tryParse(dotenv.env['BUBBLE_FONT_SIZE'] ?? '15') ?? 15.0;&#10;&#10;    _instance.tailWidth = double.tryParse(dotenv.env['TAIL_WIDTH'] ?? '18') ?? 18.0;&#10;    _instance.tailHeight = double.tryParse(dotenv.env['TAIL_HEIGHT'] ?? '14') ?? 14.0;&#10;    _instance.tailShadowElevation = double.tryParse(dotenv.env['TAIL_SHADOW_ELEVATION'] ?? '6') ?? 6.0;&#10;&#10;    _instance.userDotRadius = double.tryParse(dotenv.env['USER_DOT_RADIUS'] ?? '5') ?? 5.0;&#10;&#10;    _instance.usersListButtonWidth = double.tryParse(dotenv.env['USERS_LIST_BUTTON_WIDTH'] ?? '15.0') ?? 15.0;&#10;    _instance.usersListButtonHeight = double.tryParse(dotenv.env['USERS_LIST_BUTTON_HEIGHT'] ?? '10.0') ?? 10.0;&#10;    _instance.usersListButtonFontSize = int.tryParse(dotenv.env['USERS_LIST_BUTTON_FONT_SIZE'] ?? '10') ?? 10;&#10;&#10;    _instance.fontFamily = dotenv.env['FONT_FAMILY'] ?? 'RobotoMono';&#10;&#10;    // GRPC Settings&#10;    _instance.grpcHost = dotenv.env['GRPC_HOST'] ?? 'localhost';&#10;    _instance.grpcPort = int.tryParse(dotenv.env['GRPC_PORT'] ?? '50051') ?? 50051;&#10;    _instance.grpcSecure = dotenv.env['GRPC_SECURE']?.toLowerCase() == 'true';&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_dotenv/flutter_dotenv.dart';&#10;&#10;class AppConfig {&#10;  static final AppConfig _instance = AppConfig._internal();&#10;&#10;  late final String appName;&#10;  late final String appVersion;&#10;  late final String appEnv;&#10;&#10;  late final double maxGridSize;&#10;  late final double minGridSize;&#10;  late final double majorGridlineSpacing;&#10;  late final double majorGridlineWidth;&#10;  late final double minorGridlineSpacing;&#10;  late final double minorGridlineWidth;&#10;  late final double originWidth;&#10;&#10;  late final double bubbleWidth;&#10;  late final double bubbleHeight;&#10;  late final double bubblePadding;&#10;  late final double bubbleOpacity;&#10;  late final double bubbleCornerRadius;&#10;  late final double bubbleBorderWidth;&#10;  late final double bubbleFontSize;&#10;&#10;  late final double tailWidth;&#10;  late final double tailHeight;&#10;  late final double tailShadowElevation;&#10;&#10;  late final double userDotRadius;&#10;&#10;  late final double usersListButtonWidth;&#10;  late final double usersListButtonHeight;&#10;  late final int usersListButtonFontSize;&#10;&#10;  late final String fontFamily;&#10;&#10;  late final String grpcHost;&#10;  late final int grpcPort;&#10;  late final bool grpcSecure;&#10;&#10;  static const List&lt;Color&gt; userColors = [&#10;    Colors.red,&#10;    Colors.blue,&#10;    Colors.green,&#10;    Colors.orange,&#10;    Colors.purple,&#10;    Colors.yellow,&#10;    Colors.cyan,&#10;    Colors.pink,&#10;    Colors.teal,&#10;    Colors.lime,&#10;  ];&#10;&#10;  AppConfig._internal();&#10;&#10;  factory AppConfig() =&gt; _instance;&#10;&#10;  static Future&lt;void&gt; load() async {&#10;    const envPath = String.fromEnvironment('ENV_PATH');&#10;&#10;    await dotenv.load(fileName: envPath.isNotEmpty ? envPath : '.env');&#10;&#10;    // App Settings&#10;    _instance.appName = dotenv.env['APP_NAME'] ?? 'flutter-grpc-client';&#10;    _instance.appVersion = dotenv.env['APP_VERSION'] ?? '1.0.0';&#10;    _instance.appEnv = dotenv.env['APP_ENV'] ?? 'localhost';&#10;&#10;    // UI Settings&#10;    _instance.maxGridSize = double.tryParse(dotenv.env['MAX_GRID_SIZE'] ?? '10000.0') ?? 10000.0;&#10;    _instance.minGridSize = double.tryParse(dotenv.env['MIN_GRID_SIZE'] ?? '-10000.0') ?? -10000.0;&#10;    _instance.majorGridlineSpacing = double.tryParse(dotenv.env['MAJOR_GRIDLINE_SPACING'] ?? '200') ?? 200.0;&#10;    _instance.majorGridlineWidth = double.tryParse(dotenv.env['MAJOR_GRIDLINE_WIDTH'] ?? '1.0') ?? 1.0;&#10;    _instance.minorGridlineSpacing = double.tryParse(dotenv.env['MINOR_GRIDLINE_SPACING'] ?? '10') ?? 10.0;&#10;    _instance.minorGridlineWidth = double.tryParse(dotenv.env['MINOR_GRIDLINE_WIDTH'] ?? '0.5') ?? 0.5;&#10;    _instance.originWidth = double.tryParse(dotenv.env['ORIGIN_WIDTH'] ?? '2.0') ?? 2.0;&#10;&#10;    _instance.bubbleWidth = double.tryParse(dotenv.env['BUBBLE_WIDTH'] ?? '140') ?? 140.0;&#10;    _instance.bubbleHeight = double.tryParse(dotenv.env['BUBBLE_HEIGHT'] ?? '44') ?? 44.0;&#10;    _instance.bubblePadding = double.tryParse(dotenv.env['BUBBLE_PADDING'] ?? '12') ?? 12.0;&#10;    _instance.bubbleOpacity = double.tryParse(dotenv.env['BUBBLE_OPACITY'] ?? '0.85') ?? 0.85;&#10;    _instance.bubbleCornerRadius = double.tryParse(dotenv.env['BUBBLE_CORNER_RADIUS'] ?? '18') ?? 18.0;&#10;    _instance.bubbleBorderWidth = double.tryParse(dotenv.env['BUBBLE_BORDER_WIDTH'] ?? '1.5') ?? 1.5;&#10;    _instance.bubbleFontSize = double.tryParse(dotenv.env['BUBBLE_FONT_SIZE'] ?? '15') ?? 15.0;&#10;&#10;    _instance.tailWidth = double.tryParse(dotenv.env['TAIL_WIDTH'] ?? '18') ?? 18.0;&#10;    _instance.tailHeight = double.tryParse(dotenv.env['TAIL_HEIGHT'] ?? '14') ?? 14.0;&#10;    _instance.tailShadowElevation = double.tryParse(dotenv.env['TAIL_SHADOW_ELEVATION'] ?? '6') ?? 6.0;&#10;&#10;    _instance.userDotRadius = double.tryParse(dotenv.env['USER_DOT_RADIUS'] ?? '5') ?? 5.0;&#10;&#10;    _instance.usersListButtonWidth = double.tryParse(dotenv.env['USERS_LIST_BUTTON_WIDTH'] ?? '15.0') ?? 15.0;&#10;    _instance.usersListButtonHeight = double.tryParse(dotenv.env['USERS_LIST_BUTTON_HEIGHT'] ?? '10.0') ?? 10.0;&#10;    _instance.usersListButtonFontSize = int.tryParse(dotenv.env['USERS_LIST_BUTTON_FONT_SIZE'] ?? '10') ?? 10;&#10;&#10;    _instance.fontFamily = dotenv.env['FONT_FAMILY'] ?? 'RobotoMono';&#10;&#10;    // GRPC Settings&#10;    _instance.grpcHost = dotenv.env['GRPC_HOST'] ?? 'localhost';&#10;    _instance.grpcPort = int.tryParse(dotenv.env['GRPC_PORT'] ?? '50051') ?? 50051;&#10;    _instance.grpcSecure = dotenv.env['GRPC_SECURE']?.toLowerCase() == 'true';&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/client/lib/widgets/available_user.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/widgets/available_user.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../singletons/logger.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class AvailableUser extends StatelessWidget {&#10;  final GrpcUser user;&#10;  final VoidCallback onTap;&#10;  final VoidCallback onTakeTrip;&#10;&#10;  const AvailableUser({&#10;    super.key,&#10;    required this.user,&#10;    required this.onTap,&#10;    required this.onTakeTrip,&#10;  });&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final Logger logger = Logger();&#10;    return ListTile(&#10;      title: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.start,&#10;        children: [&#10;          Text(&#10;            user.username ?? 'Unknown',&#10;            style: TextStyle(color: user.color),&#10;          ),&#10;          Text(&#10;            'Location: (${user.currentX}, ${user.currentY})',&#10;            style: Theme.of(context).textTheme.bodySmall,&#10;          ),&#10;          const SizedBox(height: 8),&#10;          Row(&#10;            children: [&#10;              Expanded(&#10;                child: SizedBox(&#10;                  width: AppConfig().usersListButtonWidth,&#10;                  height: AppConfig().usersListButtonHeight,&#10;                  child: ElevatedButton(&#10;                    onPressed: onTakeTrip,&#10;                    style: ElevatedButton.styleFrom(&#10;                      padding: EdgeInsets.zero, // Remove default padding&#10;                    ),&#10;                    child: Center(&#10;                      child: Text(&#10;                        'Take Trip',&#10;                        textAlign: TextAlign.center,&#10;                        style: TextStyle(&#10;                          fontSize: AppConfig().usersListButtonFontSize,&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;              ),&#10;              const SizedBox(width: 8),&#10;              Expanded(&#10;                child: SizedBox(&#10;                  width: AppConfig().usersListButtonWidth,&#10;                  height: AppConfig().usersListButtonHeight,&#10;                  child: ElevatedButton(&#10;                    onPressed: onTakeTrip,&#10;                    style: ElevatedButton.styleFrom(&#10;                      padding: EdgeInsets.zero, // Remove default padding&#10;                    ),&#10;                    child: Center(&#10;                      child: Text(&#10;                        'Show Last Trip',&#10;                        textAlign: TextAlign.center,&#10;                        style: TextStyle(&#10;                          fontSize: AppConfig().usersListButtonFontSize,&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;              ),&#10;            ],&#10;          ),&#10;        ],&#10;      ),&#10;      trailing: IconButton(&#10;        icon: const Icon(Icons.directions),&#10;        tooltip: 'Move User',&#10;        onPressed: () async {&#10;          try {&#10;            final response = await GrpcClient().moveUser(user.username);&#10;            if (response.status == TrackerStatus.OK) {&#10;              logger.info(response.message);&#10;            } else {&#10;              logger.error('Failed to move user -&gt; $response}');&#10;            }&#10;          } catch (e) {&#10;            logger.error('Error moving user: $e');&#10;          }&#10;        },&#10;      ),&#10;      onTap: onTap,&#10;    );&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/grpc_client.dart';&#10;import '../singletons/logger.dart';&#10;import '../proto/tracker.pbgrpc.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class AvailableUser extends StatelessWidget {&#10;  final GrpcUser user;&#10;  final VoidCallback onTap;&#10;  final VoidCallback onTakeTrip;&#10;&#10;  const AvailableUser({&#10;    super.key,&#10;    required this.user,&#10;    required this.onTap,&#10;    required this.onTakeTrip,&#10;  });&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final Logger logger = Logger();&#10;    return ListTile(&#10;      title: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.start,&#10;        children: [&#10;          Text(&#10;            user.username ?? 'Unknown',&#10;            style: TextStyle(color: user.color),&#10;          ),&#10;          Text(&#10;            'Location: (${user.currentX}, ${user.currentY})',&#10;            style: Theme.of(context).textTheme.bodySmall,&#10;          ),&#10;          const SizedBox(height: 8),&#10;          Row(&#10;            children: [&#10;              Expanded(&#10;                child: SizedBox(&#10;                  width: AppConfig().usersListButtonWidth,&#10;                  height: AppConfig().usersListButtonHeight,&#10;                  child: ElevatedButton(&#10;                    onPressed: onTakeTrip,&#10;                    style: ElevatedButton.styleFrom(&#10;                      padding: EdgeInsets.zero, // Remove default padding&#10;                    ),&#10;                    child: Center(&#10;                      child: Text(&#10;                        'Take Trip',&#10;                        textAlign: TextAlign.center,&#10;                        style: TextStyle(&#10;                          fontSize: AppConfig().usersListButtonFontSize,&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;              ),&#10;              const SizedBox(width: 8),&#10;              Expanded(&#10;                child: SizedBox(&#10;                  width: AppConfig().usersListButtonWidth,&#10;                  height: AppConfig().usersListButtonHeight,&#10;                  child: ElevatedButton(&#10;                    onPressed: onTakeTrip,&#10;                    style: ElevatedButton.styleFrom(&#10;                      padding: EdgeInsets.zero, // Remove default padding&#10;                    ),&#10;                    child: Center(&#10;                      child: Text(&#10;                        'Show Last Trip',&#10;                        textAlign: TextAlign.center,&#10;                        style: TextStyle(&#10;                          fontSize: AppConfig().usersListButtonFontSize,&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;              ),&#10;            ],&#10;          ),&#10;        ],&#10;      ),&#10;      trailing: IconButton(&#10;        icon: const Icon(Icons.directions),&#10;        tooltip: 'Move User',&#10;        onPressed: () async {&#10;          try {&#10;            final response = await GrpcClient().moveUser(user.username);&#10;            if (response.status == TrackerStatus.OK) {&#10;              logger.info(response.message);&#10;            } else {&#10;              logger.error('Failed to move user -&gt; $response}');&#10;            }&#10;          } catch (e) {&#10;            logger.error('Error moving user: $e');&#10;          }&#10;        },&#10;      ),&#10;      onTap: onTap,&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/client/lib/widgets/existing_users.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/client/lib/widgets/existing_users.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import '../singletons/logger.dart';&#10;&#10;import 'available_user.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class ExistingUsers extends StatelessWidget {&#10;  final Map&lt;String, GrpcUser&gt; users;&#10;  final Function(GrpcUser) onUserTap;&#10;  final Function(GrpcUser) onTakeTrip;&#10;  final _logger = Logger();&#10;&#10;  ExistingUsers({&#10;    super.key,&#10;    required this.users,&#10;    required this.onUserTap,&#10;    required this.onTakeTrip,&#10;  });&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    _logger.debug('ExistingUsers rebuilding with ${users.length} users');&#10;&#10;    return Container(&#10;      width: AppConfig().usersListDisplayWidth,&#10;      decoration: BoxDecoration(&#10;        color: Colors.white,&#10;        borderRadius: BorderRadius.circular(8),&#10;        boxShadow: const [&#10;          BoxShadow(&#10;            color: Colors.black26,&#10;            blurRadius: 4,&#10;            offset: Offset(2, 2),&#10;          ),&#10;        ],&#10;      ),&#10;      child: Column(&#10;        children: [&#10;          Padding(&#10;            padding: const EdgeInsets.all(8.0),&#10;            child: Text(&#10;              'Available Users',&#10;              style: Theme.of(context).textTheme.titleMedium,&#10;            ),&#10;          ),&#10;          Expanded(&#10;            child: ListView.builder(&#10;              itemCount: users.length,&#10;              itemBuilder: (context, index) {&#10;                final user = users.values.elementAt(index);&#10;                return AvailableUser(&#10;                  key: ValueKey(user.username),&#10;                  user: user,&#10;                  onTap: () =&gt; onUserTap(user),&#10;                  onTakeTrip: () =&gt; onTakeTrip(user),&#10;                );&#10;              },&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import '../singletons/logger.dart';&#10;&#10;import 'available_user.dart';&#10;import '../classes/grpc_user.dart';&#10;import '../singletons/app_config.dart';&#10;&#10;class ExistingUsers extends StatelessWidget {&#10;  final Map&lt;String, GrpcUser&gt; users;&#10;  final Function(GrpcUser) onUserTap;&#10;  final Function(GrpcUser) onTakeTrip;&#10;  final _logger = Logger();&#10;&#10;  ExistingUsers({&#10;    super.key,&#10;    required this.users,&#10;    required this.onUserTap,&#10;    required this.onTakeTrip,&#10;  });&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    _logger.debug('ExistingUsers rebuilding with ${users.length} users');&#10;&#10;    return Container(&#10;      width: AppConfig().usersListDisplayWidth,&#10;      decoration: BoxDecoration(&#10;        color: Colors.white,&#10;        borderRadius: BorderRadius.circular(8),&#10;        boxShadow: const [&#10;          BoxShadow(&#10;            color: Colors.black26,&#10;            blurRadius: 4,&#10;            offset: Offset(2, 2),&#10;          ),&#10;        ],&#10;      ),&#10;      child: Column(&#10;        children: [&#10;          Padding(&#10;            padding: const EdgeInsets.all(8.0),&#10;            child: Text(&#10;              'Available Users',&#10;              style: Theme.of(context).textTheme.titleMedium,&#10;            ),&#10;          ),&#10;          Expanded(&#10;            child: ListView.builder(&#10;              itemCount: users.length,&#10;              itemBuilder: (context, index) {&#10;                final user = users.values.elementAt(index);&#10;                return AvailableUser(&#10;                  key: ValueKey(user.username),&#10;                  user: user,&#10;                  onTap: () =&gt; onUserTap(user),&#10;                  onTakeTrip: () =&gt; onTakeTrip(user),&#10;                );&#10;              },&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>