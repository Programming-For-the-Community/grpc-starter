// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.20.3
// source: tracker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "";

export enum TrackerStatus {
  OK = 0,
  USER_ALREADY_EXISTS = 400,
  USER_NOT_CREATED = 401,
  USER_NOT_FOUND = 402,
  PATH_NOT_FOUND = 403,
  UNRECOGNIZED = -1,
}

export function trackerStatusFromJSON(object: any): TrackerStatus {
  switch (object) {
    case 0:
    case "OK":
      return TrackerStatus.OK;
    case 400:
    case "USER_ALREADY_EXISTS":
      return TrackerStatus.USER_ALREADY_EXISTS;
    case 401:
    case "USER_NOT_CREATED":
      return TrackerStatus.USER_NOT_CREATED;
    case 402:
    case "USER_NOT_FOUND":
      return TrackerStatus.USER_NOT_FOUND;
    case 403:
    case "PATH_NOT_FOUND":
      return TrackerStatus.PATH_NOT_FOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackerStatus.UNRECOGNIZED;
  }
}

export function trackerStatusToJSON(object: TrackerStatus): string {
  switch (object) {
    case TrackerStatus.OK:
      return "OK";
    case TrackerStatus.USER_ALREADY_EXISTS:
      return "USER_ALREADY_EXISTS";
    case TrackerStatus.USER_NOT_CREATED:
      return "USER_NOT_CREATED";
    case TrackerStatus.USER_NOT_FOUND:
      return "USER_NOT_FOUND";
    case TrackerStatus.PATH_NOT_FOUND:
      return "PATH_NOT_FOUND";
    case TrackerStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Username {
  name: string;
}

export interface User {
  name: string;
  currentLocation: Location | undefined;
  pathsTraveled: { [key: number]: Path };
}

export interface User_PathsTraveledEntry {
  key: number;
  value: Path | undefined;
}

export interface Location {
  x?: number | undefined;
  y?: number | undefined;
}

export interface Path {
  pathTraveled: Location[];
}

export interface UserResponse {
  status: TrackerStatus;
  message: string;
  user?: User | undefined;
}

export interface LocationResponse {
  status: TrackerStatus;
  message: string;
  userName: Username | undefined;
  location?: Location | undefined;
}

export interface PathRequest {
  userName: string;
  pathKey: string;
}

function createBaseUsername(): Username {
  return { name: "" };
}

export const Username: MessageFns<Username> = {
  encode(message: Username, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Username {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsername();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Username {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Username): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Username>, I>>(base?: I): Username {
    return Username.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Username>, I>>(object: I): Username {
    const message = createBaseUsername();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return { name: "", currentLocation: undefined, pathsTraveled: {} };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.currentLocation !== undefined) {
      Location.encode(message.currentLocation, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pathsTraveled).forEach(([key, value]) => {
      User_PathsTraveledEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currentLocation = Location.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = User_PathsTraveledEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pathsTraveled[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      currentLocation: isSet(object.currentLocation) ? Location.fromJSON(object.currentLocation) : undefined,
      pathsTraveled: isObject(object.pathsTraveled)
        ? Object.entries(object.pathsTraveled).reduce<{ [key: number]: Path }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Path.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.currentLocation !== undefined) {
      obj.currentLocation = Location.toJSON(message.currentLocation);
    }
    if (message.pathsTraveled) {
      const entries = Object.entries(message.pathsTraveled);
      if (entries.length > 0) {
        obj.pathsTraveled = {};
        entries.forEach(([k, v]) => {
          obj.pathsTraveled[k] = Path.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.name = object.name ?? "";
    message.currentLocation = (object.currentLocation !== undefined && object.currentLocation !== null)
      ? Location.fromPartial(object.currentLocation)
      : undefined;
    message.pathsTraveled = Object.entries(object.pathsTraveled ?? {}).reduce<{ [key: number]: Path }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = Path.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUser_PathsTraveledEntry(): User_PathsTraveledEntry {
  return { key: 0, value: undefined };
}

export const User_PathsTraveledEntry: MessageFns<User_PathsTraveledEntry> = {
  encode(message: User_PathsTraveledEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      Path.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_PathsTraveledEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_PathsTraveledEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Path.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User_PathsTraveledEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? Path.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: User_PathsTraveledEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Path.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User_PathsTraveledEntry>, I>>(base?: I): User_PathsTraveledEntry {
    return User_PathsTraveledEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_PathsTraveledEntry>, I>>(object: I): User_PathsTraveledEntry {
    const message = createBaseUser_PathsTraveledEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Path.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseLocation(): Location {
  return { x: undefined, y: undefined };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== undefined) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : undefined,
      y: isSet(object.y) ? globalThis.Number(object.y) : undefined,
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.x !== undefined) {
      obj.x = message.x;
    }
    if (message.y !== undefined) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Location>, I>>(base?: I): Location {
    return Location.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Location>, I>>(object: I): Location {
    const message = createBaseLocation();
    message.x = object.x ?? undefined;
    message.y = object.y ?? undefined;
    return message;
  },
};

function createBasePath(): Path {
  return { pathTraveled: [] };
}

export const Path: MessageFns<Path> = {
  encode(message: Path, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pathTraveled) {
      Location.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Path {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pathTraveled.push(Location.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Path {
    return {
      pathTraveled: globalThis.Array.isArray(object?.pathTraveled)
        ? object.pathTraveled.map((e: any) => Location.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Path): unknown {
    const obj: any = {};
    if (message.pathTraveled?.length) {
      obj.pathTraveled = message.pathTraveled.map((e) => Location.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Path>, I>>(base?: I): Path {
    return Path.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Path>, I>>(object: I): Path {
    const message = createBasePath();
    message.pathTraveled = object.pathTraveled?.map((e) => Location.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserResponse(): UserResponse {
  return { status: 0, message: "", user: undefined };
}

export const UserResponse: MessageFns<UserResponse> = {
  encode(message: UserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserResponse {
    return {
      status: isSet(object.status) ? trackerStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: UserResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = trackerStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserResponse>, I>>(base?: I): UserResponse {
    return UserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserResponse>, I>>(object: I): UserResponse {
    const message = createBaseUserResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseLocationResponse(): LocationResponse {
  return { status: 0, message: "", userName: undefined, location: undefined };
}

export const LocationResponse: MessageFns<LocationResponse> = {
  encode(message: LocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.userName !== undefined) {
      Username.encode(message.userName, writer.uint32(26).fork()).join();
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userName = Username.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationResponse {
    return {
      status: isSet(object.status) ? trackerStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      userName: isSet(object.userName) ? Username.fromJSON(object.userName) : undefined,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: LocationResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = trackerStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.userName !== undefined) {
      obj.userName = Username.toJSON(message.userName);
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationResponse>, I>>(base?: I): LocationResponse {
    return LocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationResponse>, I>>(object: I): LocationResponse {
    const message = createBaseLocationResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.userName = (object.userName !== undefined && object.userName !== null)
      ? Username.fromPartial(object.userName)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBasePathRequest(): PathRequest {
  return { userName: "", pathKey: "" };
}

export const PathRequest: MessageFns<PathRequest> = {
  encode(message: PathRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userName !== "") {
      writer.uint32(10).string(message.userName);
    }
    if (message.pathKey !== "") {
      writer.uint32(18).string(message.pathKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pathKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathRequest {
    return {
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      pathKey: isSet(object.pathKey) ? globalThis.String(object.pathKey) : "",
    };
  },

  toJSON(message: PathRequest): unknown {
    const obj: any = {};
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.pathKey !== "") {
      obj.pathKey = message.pathKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathRequest>, I>>(base?: I): PathRequest {
    return PathRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathRequest>, I>>(object: I): PathRequest {
    const message = createBasePathRequest();
    message.userName = object.userName ?? "";
    message.pathKey = object.pathKey ?? "";
    return message;
  },
};

export interface Tracker {
  /** Create a user */
  CreateUser(request: Username): Promise<UserResponse>;
  /** Get all the created users */
  GetUsers(request: Empty): Observable<UserResponse>;
  /** Get the requested user */
  GetUser(request: Username): Promise<UserResponse>;
  /** Stream the location of the provided user */
  GetLocation(request: Username): Observable<UserResponse>;
  /** Get the current location of the provided user */
  GetCurrentLocation(request: Username): Promise<LocationResponse>;
  /** Get the last path traversed by the provided user */
  GetLastPath(request: Username): Observable<LocationResponse>;
  /** Get the request path traversed by the provided user */
  GetPath(request: PathRequest): Observable<LocationResponse>;
  /** Randomly move the user to a new location */
  MoveUser(request: Username): Promise<UserResponse>;
  /** Move the user through a series of random locations, creating a path traveled */
  TakeTrip(request: Username): Promise<UserResponse>;
  /** Get the current locations of the provided users */
  GetLocations(request: Observable<Username>): Observable<LocationResponse>;
}

export const TrackerServiceName = "Tracker";
export class TrackerClientImpl implements Tracker {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TrackerServiceName;
    this.rpc = rpc;
    this.CreateUser = this.CreateUser.bind(this);
    this.GetUsers = this.GetUsers.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.GetLocation = this.GetLocation.bind(this);
    this.GetCurrentLocation = this.GetCurrentLocation.bind(this);
    this.GetLastPath = this.GetLastPath.bind(this);
    this.GetPath = this.GetPath.bind(this);
    this.MoveUser = this.MoveUser.bind(this);
    this.TakeTrip = this.TakeTrip.bind(this);
    this.GetLocations = this.GetLocations.bind(this);
  }
  CreateUser(request: Username): Promise<UserResponse> {
    const data = Username.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUser", data);
    return promise.then((data) => UserResponse.decode(new BinaryReader(data)));
  }

  GetUsers(request: Empty): Observable<UserResponse> {
    const data = Empty.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetUsers", data);
    return result.pipe(map((data) => UserResponse.decode(new BinaryReader(data))));
  }

  GetUser(request: Username): Promise<UserResponse> {
    const data = Username.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUser", data);
    return promise.then((data) => UserResponse.decode(new BinaryReader(data)));
  }

  GetLocation(request: Username): Observable<UserResponse> {
    const data = Username.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetLocation", data);
    return result.pipe(map((data) => UserResponse.decode(new BinaryReader(data))));
  }

  GetCurrentLocation(request: Username): Promise<LocationResponse> {
    const data = Username.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrentLocation", data);
    return promise.then((data) => LocationResponse.decode(new BinaryReader(data)));
  }

  GetLastPath(request: Username): Observable<LocationResponse> {
    const data = Username.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetLastPath", data);
    return result.pipe(map((data) => LocationResponse.decode(new BinaryReader(data))));
  }

  GetPath(request: PathRequest): Observable<LocationResponse> {
    const data = PathRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "GetPath", data);
    return result.pipe(map((data) => LocationResponse.decode(new BinaryReader(data))));
  }

  MoveUser(request: Username): Promise<UserResponse> {
    const data = Username.encode(request).finish();
    const promise = this.rpc.request(this.service, "MoveUser", data);
    return promise.then((data) => UserResponse.decode(new BinaryReader(data)));
  }

  TakeTrip(request: Username): Promise<UserResponse> {
    const data = Username.encode(request).finish();
    const promise = this.rpc.request(this.service, "TakeTrip", data);
    return promise.then((data) => UserResponse.decode(new BinaryReader(data)));
  }

  GetLocations(request: Observable<Username>): Observable<LocationResponse> {
    const data = request.pipe(map((request) => Username.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "GetLocations", data);
    return result.pipe(map((data) => LocationResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
